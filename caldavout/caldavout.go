// Package caldavout generates HTTP requests to CalDAV servers to generate
// CalDAV events for Namecoin name expiration.
package caldavout

import (
	"bytes"
	"context"
	"fmt"
	"github.com/hlandau/nccald/icsutil"
	"github.com/hlandau/nccald/types"
	"github.com/hlandau/xlog"
	"github.com/namecoin/ncbtcjson"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"
)

var log, Log = xlog.New("caldavout")

// Configuration data for CalDAV operations.
type Config struct {
	// Username and password to use to authenticate. If left blank, no
	// authentication is used.
	User, Pass string
}

// MultiError represents multiple errors which occurred during CalDAV
// operations.
type MultiError []error

// Implements error.
func (merr MultiError) Error() string {
	var b strings.Builder
	b.WriteString("multiple errors updating CalDAV resources: \n")
	for _, e := range merr {
		b.WriteString("- ")
		b.WriteString(e.Error())
		b.WriteRune('\n')
	}
	return b.String()
}

// Put generates zero or more HTTP PUT requests to update resources on a CalDAV
// server. The URL should be an URL to a CalDAV calendar resource; the URLs to
// individual events will be generated by appending a slash (if it does not end
// in a slash) and a generated filename.
func Put(ctx context.Context, now time.Time, url string, cfg *Config, showInfo []ncbtcjson.NameShowResult, extraInfo []types.ExtraNameInfo) error {
	var merr MultiError

	for i := range showInfo {
		// Generate an ICS file containing only one event.
		data, err := icsutil.GenerateICS(now,
			[]ncbtcjson.NameShowResult{showInfo[i]},
			[]types.ExtraNameInfo{extraInfo[i]})
		if err != nil {
			log.Errore(err, "error generating ICS data for CalDAV update for name", showInfo[i].Name)
			merr = append(merr, err)
			continue
		}

		eventURL, err := generateURL(url, &showInfo[i])
		if err != nil {
			log.Errore(err, "error parsing or generating CalDAV URL:", url)
			merr = append(merr, err)
			continue
		}

		log.Debugf("using URL %q for name %q", eventURL, showInfo[i].Name)
		err = PutRaw(ctx, cfg, eventURL, []byte(data))
		if err != nil {
			log.Errore(err, "error while updating CalDAV for name", showInfo[i].Name)
			merr = append(merr, err)
			continue
		}
	}

	if len(merr) > 0 {
		return merr
	}

	return nil
}

// Generates URL to use for the ICS event for a specific name.
func generateURL(baseURL string, r *ncbtcjson.NameShowResult) (string, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return "", err
	}

	u.Path = path.Join(u.Path, "nccald-"+icsutil.EncodeName(r.Name)+".ics")
	return u.String(), nil
}

// PutRaw PUTs a resource to a CalDAV server. This is intended for use to
// generate PUT requests and it is assumed the data provided is an ICS file
// containing a single VEVENT inside a single VCALENDAR. The URL should be
// something like "https://.../calendar/foo/bar.ics", not the URL to the
// calendar itself.
func PutRaw(ctx context.Context, cfg *Config, url string, data []byte) error {
	// Radicale, a popular CalDAV server, apparently has a bug where it cannot
	// process PUT requests which do not provide an exact Content-Length. This
	// function will set the Content-Length header where the argument is a
	// *bytes.Reader, so we don't need to do anything special here to support
	// Radicale.
	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(data))
	if err != nil {
		return err
	}

	commonReq(req, cfg)
	req.Header.Set("Content-Type", "text/calendar; charset=utf-8")

	res, err := http.DefaultClient.Do(req)
	if res != nil {
		defer res.Body.Close()
	}
	if err != nil {
		return err
	}

	if res.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code when PUTting CalDAV ICS file: %d", res.StatusCode)
	}

	return nil
}

// DeleteRaw DELETEs a resource from a CalDAV server. This is intended for use
// to generate DELETE requests to delete individual ICS event resources. The
// URL should be something like "https://.../calendar/foo/bar.ics", not the URL
// to the calendar itself.
func DeleteRaw(ctx context.Context, cfg *Config, url string) error {
	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return err
	}

	commonReq(req, cfg)

	res, err := http.DefaultClient.Do(req)
	if res != nil {
		defer res.Body.Close()
	}
	if err != nil {
		return err
	}

	// Allow 404 to allow idempotency.
	if res.StatusCode != http.StatusOK && res.StatusCode != http.StatusNotFound {
		return fmt.Errorf("unexpected status code when DELETEing CalDAV ICS resource: %d", res.StatusCode)
	}

	return nil
}

// Set common fields in an HTTP request.
func commonReq(req *http.Request, cfg *Config) {
	req.Header.Set("User-Agent", "nccald")
	if cfg.User != "" || cfg.Pass != "" {
		req.SetBasicAuth(cfg.User, cfg.Pass)
	}
}
